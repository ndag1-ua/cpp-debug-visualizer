<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>C++ Debug Visualizer</title>

	<link href="${cssUri}" rel="stylesheet">
	<script src="${scriptUri}"></script>
	  
</head>
<body>
	<div id="container">
		<div id="top" class="drag-container">
			<h2>Top Panel</h2>
			<div id="top-data" class="canvas-content">
				<!-- Aquí meterás tu contenido dinámico del top -->
			</div>
		</div>
		<div id="divider"></div>
		<div id="bottom" class="drag-container">
            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                <button onclick="requestUpdate()">Update</button>
            </div>
            <div id="bottom-data" class="canvas-content">
				<!-- Aquí meterás el contenido HTML generado de App.visualizeData() -->
			</div>
		</div>
	</div>

	<script>
        const vscode = acquireVsCodeApi();

        const button = document.getElementById('button');
		const container = document.getElementById('container');
		const divider = document.getElementById('divider');

		let isDragging = false;

		divider.addEventListener('mousedown', () => {
			isDragging = true;
			document.body.style.cursor = 'row-resize';
		});

		document.addEventListener('mouseup', () => {
			isDragging = false;
			document.body.style.cursor = 'default';
		});

		document.addEventListener('mousemove', (e) => {
			if (!isDragging) return;

			const offsetY = e.clientY;
			const containerRect = container.getBoundingClientRect();

			// Calcular el tamaño relativo al contenedor
			const topHeight = offsetY - containerRect.top;
			const bottomHeight = containerRect.bottom - offsetY - 5; // 5px es el alto del divider

			if (topHeight < 50 || bottomHeight < 50) return; // límite mínimo

			// Actualizar las filas del grid
			container.style.gridTemplateRows = `${topHeight}px 5px ${bottomHeight}px`;

			updateAllLines();
		});

        function requestUpdate() {
            vscode.postMessage({ type: 'update-variables' });
        }

        window.addEventListener('message', event => {
            if (event.data.type === 'variables') {
                document.getElementById('bottom-data').innerHTML = event.data.data;
				drawPointerLines();
            }
        });

		window.addEventListener('message', event => {
            if (event.data.type === 'data-types') {
                document.getElementById('top-data').innerHTML = event.data.data;
				drawPointerLines();
            }
        });

		function makeDraggableScroll(containerId) {
			const container = document.getElementById(containerId);
			const content = container.querySelector('.canvas-content');

			let isDragging = false;
			let startX, startY;
			let offsetX = 0, offsetY = 0;

			container.addEventListener('mousedown', (e) => {
				isDragging = true;
				container.classList.add('dragging');
				startX = e.clientX - offsetX;
				startY = e.clientY - offsetY;
			});

			document.addEventListener('mouseup', () => {
				isDragging = false;
				container.classList.remove('dragging');
			});

			document.addEventListener('mousemove', (e) => {
				if (!isDragging) return;
				e.preventDefault();

				offsetX = e.clientX - startX;
				offsetY = e.clientY - startY;

				// Límites de desplazamiento
				const minX = Math.min(0, container.clientWidth - content.scrollWidth);
				const maxX = 0;
				const minY = Math.min(0, container.clientHeight - content.scrollHeight);
				const maxY = 0;

				// Aplicar límites
				offsetX = Math.max(minX, Math.min(maxX, offsetX));
				offsetY = Math.max(minY, Math.min(maxY, offsetY));

				content.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
				updateAllLines();
			});

		}

		makeDraggableScroll('top');
		makeDraggableScroll('bottom');

		function drawPointerLines() {
			// Quitar líneas anteriores
			if (window._pointerLines) {
				window._pointerLines.forEach(line => line.remove());
			}
			window._pointerLines = [];

			document.querySelectorAll('[id^="from-"]').forEach(fromEl => {
				const uid = fromEl.id.replace('from-', '');
				const toEl = document.getElementById(`to-${uid}`);

				console.log(`fromEl: ${fromEl.id}, toEl: ${toEl ? toEl.id : 'null'}`);

				if (toEl) {
				const line = new LeaderLine(
					fromEl,
					toEl,
					{
					container: document.querySelector('#bottom-data'),
					startSocket: 'bottom',
					endSocket: 'top',
					color: 'white',
					path: 'fluid',
					startPlug: 'behind',
					endPlug: 'arrow1',
					size: 2
					}
				);
				// Guarda también los elementos para poder actualizar después
				window._pointerLines.push({ line, fromEl, toEl });
				}
			});
		}

		function updateAllLines() {
			for (const { line, fromEl, toEl } of window._pointerLines) {
				if (fromEl && toEl) {
					line.position();
				} else {
					line.remove(); // Elimina la línea si uno de los elementos no existe
					window._pointerLines = window._pointerLines.filter(l => l.line !== line); // Actualiza el array
				}
			}
		}


		window.addEventListener('resize', () => {
			updateAllLines();
		});

		document.addEventListener("click", (event) => {
			const target = event.target;
			if (target.classList.contains("type-toggle")) {
				const type = target.dataset.type;
				if (!type) return;

				// Alternar estado visual
				target.classList.toggle("active");
				target.classList.toggle("inactive");

				// Notificar al backend si es necesario
				vscode.postMessage({ type: "toggle-type", payload: type });
			}

			updateAllLines();
		});


	</script>
</body>
</html>
