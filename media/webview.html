<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>C++ Debug Visualizer</title>

	<link href="${cssUri}" rel="stylesheet">
	  
</head>
<body>
	<div id="container">
		<div id="top" class="drag-container">
			<h2>Top Panel</h2>
			<div id="top-data" class="canvas-content">
				<!-- Aquí meterás tu contenido dinámico del top -->
			</div>
		</div>
		<div id="divider"></div>
		<div id="bottom" class="drag-container">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h2>Variables</h2>
                <button onclick="requestUpdate()">Update</button>
            </div>
            <div id="bottom-data" class="canvas-content">
				<!-- Aquí meterás el contenido HTML generado de App.visualizeData() -->
			</div>
		</div>
	</div>

	<script>
        const vscode = acquireVsCodeApi();

        const button = document.getElementById('button');
		const container = document.getElementById('container');
		const divider = document.getElementById('divider');

		let isDragging = false;

		divider.addEventListener('mousedown', () => {
			isDragging = true;
			document.body.style.cursor = 'row-resize';
		});

		document.addEventListener('mouseup', () => {
			isDragging = false;
			document.body.style.cursor = 'default';
		});

		document.addEventListener('mousemove', (e) => {
			if (!isDragging) return;

			const offsetY = e.clientY;
			const containerRect = container.getBoundingClientRect();

			// Calcular el tamaño relativo al contenedor
			const topHeight = offsetY - containerRect.top;
			const bottomHeight = containerRect.bottom - offsetY - 5; // 5px es el alto del divider

			if (topHeight < 50 || bottomHeight < 50) return; // límite mínimo

			// Actualizar las filas del grid
			container.style.gridTemplateRows = `${topHeight}px 5px ${bottomHeight}px`;
		});

        function requestUpdate() {
            vscode.postMessage({ type: 'update-variables' });
        }

        window.addEventListener('message', event => {
            if (event.data.type === 'variables') {
                document.getElementById('bottom-data').innerHTML = event.data.data;
            }
        });

		function makeDraggableScroll(containerId) {
			const container = document.getElementById(containerId);
			const content = container.querySelector('.canvas-content');

			let isDragging = false;
			let startX, startY;
			let offsetX = 0, offsetY = 0;

			container.addEventListener('mousedown', (e) => {
				isDragging = true;
				container.classList.add('dragging');
				startX = e.clientX - offsetX;
				startY = e.clientY - offsetY;
			});

			document.addEventListener('mouseup', () => {
				isDragging = false;
				container.classList.remove('dragging');
			});

			document.addEventListener('mousemove', (e) => {
				if (!isDragging) return;
				e.preventDefault();

				offsetX = e.clientX - startX;
				offsetY = e.clientY - startY;

				// Límites de desplazamiento
				const minX = Math.min(0, container.clientWidth - content.scrollWidth);
				const maxX = 0;
				const minY = Math.min(0, container.clientHeight - content.scrollHeight);
				const maxY = 0;

				// Aplicar límites
				offsetX = Math.max(minX, Math.min(maxX, offsetX));
				offsetY = Math.max(minY, Math.min(maxY, offsetY));

				content.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
			});
		}

		makeDraggableScroll('top');
		makeDraggableScroll('bottom');

	</script>
</body>
</html>
